# Работа с уровнями изоляции транзакции в PostgreSQL

## Цели:
1. Научиться работать с Google Cloud Platform на уровне Google Compute Engine (IaaS).
1. Научиться управлять уровнем изолции транзации в PostgreSQL и понимать особенность работы уровней read commited и repeatable read.

## Описание выполнения домашнего задания:

### Шаг 1. Создать новый проект и инстанс виртуальной машины

> Создать новый проект в **Google Cloud Platform**, Яндекс облако или на любых ВМ, докере , например postgres2022-, где yyyymmdd год, месяц и день вашего рождения (имя проекта должно быть уникально на уровне GCP). Далее создать инстанс виртуальной машины Compute Engine с дефолтными параметрами, добавить свой ssh ключ в GCE metadata. Зайти удаленным ssh (первая сессия), не забывайте про ssh-add.

**Результат**

В качестве платформы для работы с сервисами в облаке выбрана [Yandex.Cloud](https://console.cloud.yandex.ru). Возможности поработать с GCP, невозможно зарегистрироваться.

Для подключения к ВМ, созданной в облачной платформе, заранее сгенерирован  SSH-ключ (пара ключей):

![Подготовка SSH-ключей для подключения к ВМ](/images/scr-dz01-01.png)

Создана виртуальная машина (**gchibizov-pg-20220714**):

![Виртуальная машина](/images/scr-dz01-03.png)

В интерфейсе создания ВМ подгружена ранее созданная публичная часть ключа, заведен пользователь **gchibizov**:

![Интерфейс создания ВМ в Yandex Cloude](/images/scr-dz01-02.png)

Копируем публичный IP-адрес 51.250.99.101 и пытаемся подключиться через SSH с терминала MacOS:

![Подключение через SSH к ВМ](/images/scr-dz01-04.png)

### Шаг 2. Установить PostgreSQL, подготовить две вкладки для запросов (с клиентом для PG), отключить auto commit

> Поставить **PostgreSQL**. Зайти вторым ssh (вторая сессия). Запустить везде psql из под пользователя **postgres**. Выключить **auto commit**

**Результат**

Для начала проверим версию установленной ОС и ее описание. Команда `lsb_release -a`:

![Проверка версии Ubuntu](/images/scr-dz01-05.png)

Установим Postgre с помощью команды:

```
sudo apt update && sudo apt upgrade -y && sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list' && wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add - && sudo apt-get update && sudo apt-get -y install postgresql-14
```

![Процесс установки Postgre](/images/scr-dz01-06.png)

Убедимся что кластер запущен, команда `pg_lsclusters`:

![Проверка работоспособности кластера](/images/scr-dz01-07.png)

Добавим вторую вкладку и отключи AUTOCOMMIT:

![Подготовка вкладок для работы с транзакциями](/images/scr-dz01-11.png)

### Шаг 3. Подготовить таблицу для работы с транзакциями, проверить текущий уровень изоляции для транзакций (по умолчанию)

> Сделать в первой сессии новую таблицу и наполнить ее данными `create table persons(id serial, first_name text, second_name text); insert into persons(first_name, second_name) values('ivan', 'ivanov'); insert into persons(first_name, second_name) values('petr', 'petrov'); commit;`
посмотреть текущий уровень изоляции: **show transaction isolation level**

**Результат**

Подключаемся к БД через клиента. Команда `sudo -u postgres psql`, создаем БД и проверим, что БД создана:

![Создание БД](/images/scr-dz01-09.png)

![Список БД](/images/scr-dz01-08.png)

Далее создае ым необходимую таблицу, добавим данные в таблицу и подготовим вкладку для работы:

![Подготовка данных](/images/scr-dz01-10.png)

### Шаг 4. Уровень изоляции транзакций Read Committed (по умолчанию)

> Начать новую транзакцию в обоих сессиях с дефолтным (не меняя) уровнем изоляции. В первой сессии добавить новую запись `insert into persons(first_name, second_name) values('sergey', 'sergeev');` сделать `select * from persons` во второй сессии. Видите ли вы новую запись и если да то почему? Завершить первую транзакцию - `commit;` сделать `select * from persons` во второй сессии. Видите ли вы новую запись и если да то почему? Завершите транзакцию во второй сессии.

**Результат**

По умолчанию уровень изоляции транзакций **Read Committed**. Есть прекрасная табличка, на основании которой будем прогнозировать результат работы наших команд на языке SQL.

|                 |Грязное чтение | Неповтоярющиееся чтение  | Фантомное чтение  | Аномалия сериализации |
|-----------------|---------------|--------------------------|-------------------|-----------------------|
|Read Uncommitted |   (не в PG)   |          Да              |        Да         |          Да           |
|Read Сommitted   |               |          Да              |        Да         |          Да           |
|Repeatable Read  |               |                          |     (не в PG)     |          Да           |
|Serializable     |               |                          |                   |                       |

Для нашего кейса мы используем строчку 2 в таблице. По ожиданиям, если текущая транзакция не завершена (NOT COMMITTED), то другие транзакции ее не увидят. После подтверждения транзакции, другие открытые транзакции могут увидеть результат ее работы.

![Вкладка 1. Операции с транзакцией](/images/scr-dz01-11.png)

![Вкладка 2. Операции с транзакцией](/images/scr-dz01-12.png)

Сначала в первой транзакции добавили строчку, потом зафиксировали изменения. Как и ожидалось, вторая открытая транзакция увидела изменения, внесенные первой траназкцией после ее подтверждения (состояние COMMITTED).

### Шаг 5. Уровень изоляции транзакций Repeatable Read

> Начать новые но уже repeatable read транзации - set transaction isolation level repeatable read; в первой сессии добавить новую запись `insert into persons(first_name, second_name) values('sveta', 'svetova');` сделать `select * from persons` во второй сессии. Видите ли вы новую запись и если да то почему? Завершить первую транзакцию - `commit;` сделать `select * from persons` во второй сессии. Видите ли вы новую запись и если да то почему? Завершить вторую транзакцию, сделать `select * from persons` во второй сессии. Видите ли вы новую запись и если да то почему?

**Результат**

Для нашего кейса мы используем строчку 3 в таблице. По ожиданиям, если текущая транзакция не завершена (NOT COMMITTED), то другие транзакции ее не увидят. После подтверждения транзакции, другие открытые транзакции могут увидеть результат ее работы.

![Вкладка 1. Операции с транзакцией](/images/scr-dz01-13.png)

![Вкладка 2. Операции с транзакцией](/images/scr-dz01-14.png)

Сначала в первой транзакции добавили строчку, потом зафиксировали изменения. Как и ожидалось, вторая открытая транзакция НЕ увидела изменений, внесенных первой траназкцией после ее подтверждения (состояние COMMITTED). Изменения были доступны только после завершения второй транзакции.