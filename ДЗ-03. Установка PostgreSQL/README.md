# Установка и настройка PostgteSQL в контейнере Docker

## Цели:
1. Установить PostgreSQL в Docker контейнере.
1. Настроить контейнер для внешнего подключения.

## Описание выполнения домашнего задания

### Шаг 1. Создать новый проект и инстанс виртуальной машины

> В качестве платформы с облачными сервисами будем использовать Yandex Cloud. Подготовим инстанс по шагам из ДЗ-01, не забываем про SSH-ключ.

**Результат**

Создана виртуальная машина (**gchibizov-pg-20220725**):

![Виртуальная машина](/images/scr-dz02-01.png)

Копируем публичный IP-адрес 84.201.166.234 и пытаемся подключиться через SSH с терминала MacOS:

![Подключение через SSH к ВМ](/images/scr-dz02-02.png)


### Шаг 2. Установить Docker Engine, создать каталог /var/lib/postgres, развернуть контейнеры с PostgreSQL 14 и клиентом Postgres, подготовить данные, подключиться извне

> Установим дистрибутив Docker Engine, далее развернем два контейнера на основе образа из Docker Hub и объединим их в одну общую сеть. Незначительно меняем команды, чтобы немного запомнить синтаксис и что за что отвечает. Команды берем из файлика с конспектом вебинара


**Результат**

Подготовим Docker Engine для работы + подготовим каталог `/var/lib/postgres`:

```
-- Установка Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh
rm get-docker.sh
sudo usermod -aG docker $USER

-- Создаем каталог
sudo mkdir /var/lib/postgres
```

![Установка докера + подготовка каталога](/images/scr-dz02-03.png)

Развернем контейнеры:

```
-- Создать docker-сеть
sudo docker network create pg-gc-net

-- Подключаем созданную сеть к контейнеру сервера Postgres:
sudo docker run --name pg-gc-docker --network pg-gc-net -e POSTGRES_PASSWORD=postgres -d -p 5432:5432 -v /var/lib/postgres:/var/lib/postgresql/data postgres:14

-- Запускаем отдельный контейнер с клиентом в общей сети с БД:
sudo docker run -it --rm --network pg-gc-net --name pg-gc-client postgres:14 psql -h pg-gc-docker -U postgres

```

![Разворачивание контейнеров и сети в докере](/images/scr-dz02-04.png)

Проверим, что подключение клиента идет через отдельный контейнер. Не забываем убрать параметр `--rm`:

![Разворачивание контейнеров и сети в докере](/images/scr-dz02-05.png)

Подготовим данные, создадим табличку test:

![Данные для экспериментов](/images/scr-dz02-06.png)

Подключимся с локальной машины на MacOS к контейнеру с помощью утилиты DBeaver:

![Подключение извне](/images/scr-dz02-07.png)



### Шаг 3. Удалить контейнер с сервером, создать заново и подключиться через контейнер с клиентом

> Хитрый замысел заключается в том, чтобы убедиться, что наши данные при пересоздании контейнера не исчезнут, для этого на ВМ нужно посмотреть содержимое каталога `/var/lib/postgres`.

**Результат**

Посмотрим перед удалением контейнера, а появилось ли что-нибдуь в нашем каталоге `/var/lib/postgres`:

![Содержимое каталога /var/lib/postgres](/images/scr-dz02-08.png)

Выполним действия по персозданию контейнеров и проверим запросом данные (данные должны быть на месте):

![Проверка наличия данных в БД после пересоздания контейнеров](/images/scr-dz02-09.png)


**Выводы**

Работать с Docker Engine крайне удобно, но гораздо надежнее хранить команды по созданию образов и контейнеров в отдельных файлах с понятной структурой: `Dockerfile` и `YML` для `docker-compose`. Готовые образы с Postgre (Docker Hub) могут содержать дырки в безопасности (открыты порты, открыт доступ для всех хостов, стандартным известным образом настроены роли и пароли и тп).

Основные сложности (ошибки) в процессе выполнения задания были связаны с тем, что нужно внимательно следить за текстом команд и контролировать атрибуты, ВМ от Yandex Cloud сильных проблем в настройке не прибавила, к SSH-ключам и неудобной настройке этих ключей можно адаптироваться.



